# План разработки функций кнопок

## Описание проекта

На основании `PROJECT.MD`: приложение получает URL англоязычной статьи, выполняет парсинг и по соответствующей кнопке подключает AI для выполнения нужного действия.

## Текущее состояние системы

✅ **Реализовано:**
- Парсинг статей: извлечение даты, заголовка, контента (`/api/parse`)
- Перевод статей: через OpenRouter AI, модель Deepseek (`/api/translate`)
- Интерфейс: поле ввода URL, 3 кнопки, блок результата

❌ **Требуется доработка:**
- Все три кнопки выполняют одинаковое действие (перевод)
- Нужно добавить уникальные функции для каждой кнопки

## Цель разработки

Реализовать три уникальные функции для кнопок:
1. **"О чем статья?"** — краткое описание/резюме статьи (2-3 предложения)
2. **"Тезисы"** — основные тезисы/ключевые моменты в виде списка
3. **"Пост для Telegram"** — форматированный пост с эмодзи, хештегами и форматированием

---

## Этап 1: Анализ и проектирование

### Шаг 1.1: Анализ текущей архитектуры
- [ ] Изучить текущий код `app/page.js` и функцию `handleAction`
- [ ] Изучить существующие API routes (`/api/parse`, `/api/translate`)
- [ ] Определить точки интеграции нового функционала

### Шаг 1.2: Проектирование API Endpoint

**Концепция:**
- **Endpoint:** `/api/ai-action`
- **Метод:** `POST`
- **API-route:** `app/api/ai-action/route.js`

**Входные параметры:**
```json
{
  "actionType": "О чем статья?" | "Тезисы" | "Пост для Telegram",
  "content": "текст статьи для обработки"
}
```

**Выходные данные:**
```json
{
  "result": "результат обработки AI"
}
```

### Шаг 1.3: Определение промптов для каждого действия

**"О чем статья?"** (actionType: `'О чем статья?'`):
- **System message:** "Ты эксперт по анализу текстов. Дай краткое описание статьи на русском языке (2-3 предложения)."
- **User message:** "О чем эта статья?\n\n[контент статьи]"

**"Тезисы"** (actionType: `'Тезисы'`):
- **System message:** "Ты эксперт по анализу текстов. Выдели основные тезисы статьи на русском языке в виде нумерованного списка."
- **User message:** "Выдели основные тезисы этой статьи:\n\n[контент статьи]"

**"Пост для Telegram"** (actionType: `'Пост для Telegram'`):
- **System message:** "Ты эксперт по созданию постов для Telegram. Создай интересный пост на русском языке с эмодзи, хештегами и форматированием (жирный текст, списки)."
- **User message:** "Создай пост для Telegram на основе этой статьи:\n\n[контент статьи]"

---

## Этап 2: Разработка Backend API

### Шаг 2.1: Создание структуры API route

**Файл:** `app/api/ai-action/route.js`

**Базовая структура:**
- [ ] Создать файл `app/api/ai-action/route.js`
- [ ] Импортировать необходимые модули (`NextResponse`)
- [ ] Создать функцию `POST` для обработки запросов
- [ ] Добавить валидацию входных параметров

### Шаг 2.2: Реализация логики определения промпта

- [ ] Создать объект/функцию для хранения промптов по `actionType`
- [ ] Реализовать выбор промпта в зависимости от `actionType`
- [ ] Добавить обработку неизвестного `actionType` (возврат ошибки)

**Структура промптов:**
```javascript
const prompts = {
  'О чем статья?': {
    system: '...',
    user: '...'
  },
  'Тезисы': { ... },
  'Пост для Telegram': { ... }
}
```

### Шаг 2.3: Интеграция с OpenRouter API

- [ ] Получить API ключ из переменных окружения (`OPENROUTER_API_KEY`)
- [ ] Получить базовый URL (`OPENAI_BASE_URL` или дефолт)
- [ ] Сформировать запрос к OpenRouter API (`/chat/completions`)
- [ ] Использовать модель `deepseek/deepseek-chat`
- [ ] Добавить необходимые заголовки (Authorization, HTTP-Referer, X-Title)

### Шаг 2.4: Обработка ответа от OpenRouter

- [ ] Проверить успешность запроса (`response.ok`)
- [ ] Распарсить JSON ответ
- [ ] Извлечь текст результата из `data.choices[0].message.content`
- [ ] Вернуть результат в формате JSON

### Шаг 2.5: Обработка ошибок

- [ ] Обработать ошибки валидации входных данных (400)
- [ ] Обработать ошибки API OpenRouter (500, 401, 429)
- [ ] Обработать сетевые ошибки (timeout, connection)
- [ ] Вернуть понятные сообщения об ошибках клиенту

### Шаг 2.6: Добавление логирования

- [ ] Добавить `console.log` для логирования промптов
- [ ] Логировать `actionType` и первые 200 символов контента
- [ ] Логировать ошибки для отладки

---

## Этап 3: Обновление Frontend

### Шаг 3.1: Анализ текущей функции handleAction

**Файл:** `app/page.js`

**Текущая логика:**
1. Проверка наличия URL
2. Парсинг статьи через `/api/parse`
3. Перевод через `/api/translate`
4. Вывод перевода в результат

**Требуемые изменения:**
- Убрать вызов `/api/translate`
- Добавить вызов `/api/ai-action` с передачей `actionType`

### Шаг 3.2: Рефакторинг функции handleAction

- [ ] Удалить код вызова `/api/translate`
- [ ] Удалить обработку результата перевода
- [ ] Добавить вызов `/api/ai-action` после парсинга
- [ ] Передать `actionType` и `parsedData.content` в API
- [ ] Обработать ответ от `/api/ai-action`
- [ ] Вывести результат в поле результата

**Новая логика handleAction:**
```javascript
1. Проверить наличие URL
2. Парсить статью через /api/parse
3. Отправить actionType и content в /api/ai-action
4. Получить результат от AI
5. Вывести результат в поле результата
```

### Шаг 3.3: Обработка состояний загрузки

- [ ] Убедиться, что `loading` устанавливается в `true` перед запросом
- [ ] Убедиться, что `loading` устанавливается в `false` после завершения
- [ ] Проверить отображение индикатора загрузки

### Шаг 3.4: Обработка ошибок на фронтенде

- [ ] Добавить try-catch блоки для каждого запроса
- [ ] Обработать ошибки парсинга
- [ ] Обработать ошибки AI запроса
- [ ] Вывести понятные сообщения об ошибках пользователю

### Шаг 3.5: Проверка работы кнопок

**Ожидаемое поведение:**
- Кнопка "О чем статья?" → передаёт `actionType: 'О чем статья?'` → получает краткое описание
- Кнопка "Тезисы" → передаёт `actionType: 'Тезисы'` → получает список тезисов
- Кнопка "Пост для Telegram" → передаёт `actionType: 'Пост для Telegram'` → получает форматированный пост

---

## Этап 4: Тестирование

### Шаг 4.1: Тестирование API Endpoint

- [ ] Протестировать `/api/ai-action` с каждым `actionType`
- [ ] Проверить валидацию входных данных (отсутствие `actionType`, пустой `content`)
- [ ] Проверить обработку неизвестного `actionType`
- [ ] Проверить обработку ошибок API OpenRouter

### Шаг 4.2: Тестирование функции "О чем статья?"

- [ ] Ввести URL англоязычной статьи
- [ ] Нажать кнопку "О чем статья?"
- [ ] Проверить получение краткого описания (2-3 предложения)
- [ ] Проверить язык результата (русский)

### Шаг 4.3: Тестирование функции "Тезисы"

- [ ] Ввести URL англоязычной статьи
- [ ] Нажать кнопку "Тезисы"
- [ ] Проверить получение списка тезисов
- [ ] Проверить форматирование (нумерованный список)
- [ ] Проверить язык результата (русский)

### Шаг 4.4: Тестирование функции "Пост для Telegram"

- [ ] Ввести URL англоязычной статьи
- [ ] Нажать кнопку "Пост для Telegram"
- [ ] Проверить наличие эмодзи в результате
- [ ] Проверить наличие хештегов
- [ ] Проверить форматирование (жирный текст, списки)
- [ ] Проверить язык результата (русский)

### Шаг 4.5: Тестирование обработки ошибок

- [ ] Протестировать с неверным URL (ошибка парсинга)
- [ ] Протестировать с пустым URL
- [ ] Протестировать с недоступным API ключом
- [ ] Проверить отображение понятных сообщений об ошибках

---

## Этап 5: Оптимизация и финализация

### Шаг 5.1: Анализ качества результатов

- [ ] Проверить качество результатов для каждой функции
- [ ] Оценить соответствие результатов требованиям
- [ ] Выявить проблемы с промптами

### Шаг 5.2: Оптимизация промптов

- [ ] Уточнить промпты для лучшего результата (при необходимости)
- [ ] Добавить дополнительные инструкции в промпты
- [ ] Протестировать улучшенные промпты

### Шаг 5.3: Оптимизация производительности

- [ ] Проверить время ответа API
- [ ] Оптимизировать размер передаваемого контента (если необходимо)
- [ ] Добавить ограничение длины контента (если необходимо)

### Шаг 5.4: Финальная проверка

- [ ] Проверить работу всех трёх функций на разных статьях
- [ ] Проверить стабильность работы
- [ ] Убедиться, что нет регрессий в существующем функционале

### Шаг 5.5: Документация

- [ ] Обновить комментарии в коде
- [ ] Убедиться, что код читаемый и понятный
- [ ] При необходимости обновить README.md

---

## Порядок выполнения (краткий)

1. **Этап 1:** Анализ и проектирование (Шаги 1.1-1.3)
2. **Этап 2:** Разработка Backend API (Шаги 2.1-2.6)
3. **Этап 3:** Обновление Frontend (Шаги 3.1-3.5)
4. **Этап 4:** Тестирование (Шаги 4.1-4.5)
5. **Этап 5:** Оптимизация и финализация (Шаги 5.1-5.5)

---

## Технические детали

### Endpoint и API-route

**Endpoint:** `/api/ai-action`  
**API-route:** `app/api/ai-action/route.js`

**Как это работает в Next.js:**
- Файл `app/api/ai-action/route.js` автоматически создаёт Endpoint `/api/ai-action`
- Когда делаем запрос на `http://localhost:3000/api/ai-action`, Next.js запускает код из `route.js`
- Endpoint = URL адрес для обращения к API
- API-route = код обработчика запросов к этому Endpoint

### Переменные окружения

- `OPENROUTER_API_KEY` — API ключ OpenRouter (из `.env.local`)
- `OPENAI_BASE_URL` — базовый URL OpenRouter API (из `.env.local` или дефолт: `https://openrouter.ai/api/v1`)

### Модель AI

- **Модель:** `deepseek/deepseek-chat`
- **Провайдер:** OpenRouter
- **Endpoint провайдера:** `https://openrouter.ai/api/v1/chat/completions`
